Making use of ASP .NET Core Dependency Injection
------------------------------------------------

> Martin Fowler has written an extensive article on [Inversion of Control Containers and the Dependency Injection Pattern](http://martinfowler.com/articles/injection.html). Microsoft Patterns and Practices also has a great description of [Dependency Injection](https://msdn.microsoft.com/en-us/library/dn178469(v=pandp.30).aspx).

> For a more detailed view of dependency injection in ASP .NET Core applications, [read the article from the Official ASP .NET Core Documentation](https://docs.asp.net/en/latest/fundamentals/dependency-injection.html).

[Our application works](configuration.md), but there is a lot of logic code in `Startup`, a place for configuration. 

We will try to extract the part of `Startup` that deals with actually getting the response from the `JSON` file in a separate class and learn how to inject that service in various places (like other services, controllers or even in `Startup`).

First of all, let's think at what public methods and properties should a greeting service should have. Basically, it should only have a single method that receives the path a user navigated to and should return a string, the response taken from the JSON file.

In order to make dependency injection work, we will make use of interfaces. Meaning we will build an interface for the greeting service, `IGreetingService`.

> To see an example with interfaces, [check this tutorial](https://github.com/microsoft-dx/csharp-fundamentals/tree/master/CSharpFundamentals/csharp09%20-%20Interfaces).

Let's create a new file, `IGreetingService.cs`:

```
public interface IGreetingService
{
    string Greet(string route);
}
```

Now, in another file, `GreetingService.cs` we will add the actual implementation of the service:

```
using System.Linq;
using Microsoft.Extensions.Configuration;

public class GreeringService : IGreetingService
{
    private IConfiguration Configuration {get;set;}

    public GreeringService(IConfiguration configuration)
    {
        Configuration = configuration;
    }
    public string Greet(string route)
    {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r => r.Key == route)
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r => r.Key == "default")
                .Value;

            return (routeMessage != null) ? routeMessage : defaultMessage;
    }
}
```

Basically, this class has the `Greet` method which contains most of the logic we had in `Startup` for retrieving  the response from the JSON file. It also has an `IConfiguration` property, this time injected in the controller (we will see a bit later where and how this is done).

Now let's take a look at the `Startup` class, this time at the `Configure` method:

```
    public void Configure(IApplicationBuilder app, IGreetingService greetingService)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet("{route}", context => 
        {
            var route = context.GetRouteValue("route").ToString();
            return context.Response.WriteAsync(greetingService.Greet(route));
        });

        app.UseRouter(routeBuilder.Build());
    }
``` 

The new thing here is that we have an `IGreetingService` parameter in the method signature that we use when returning the message. 

Both the `IGreetingService` and `IConfiguration` parameters are configured in the `ConfigureServices` method, also from `Startup`:

```
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();

        services.Add(new ServiceDescriptor(typeof(IConfiguration), 
                     provider => new ConfigurationBuilder()
                                    .SetBasePath(Directory.GetCurrentDirectory())
                                    .AddJsonFile("greetings.json", 
                                                 optional: false, 
                                                 reloadOnChange: true)
                                    .Build(), 
                     ServiceLifetime.Singleton));
                     
        services.AddTransient<IGreetingService, GreeringService>();
    }
```

First of all we add the routing service (just like in the previous examples).

The last line of this method states that every time some class requests a parameter of type `IGreetingService`, the DI (dependency injection) engine will provide it with a new (every time a new) implementation of `GreetingService`.

The second method call is the most difficult of all: it says that every time someone requests an `IConfiguration` parameter, the engine should provide the same instance (singleton) generated by this chain of method calls:
```
new ConfigurationBuilder()
                                    .SetBasePath(Directory.GetCurrentDirectory())
                                    .AddJsonFile("greetings.json", 
                                                 optional: false, 
                                                 reloadOnChange: true)
                                    .Build(), 

```

which is the same as earlier.
